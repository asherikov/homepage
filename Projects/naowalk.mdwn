[[!meta title="Nao walking module"]]

**Contents**
[[!toc]]


---
## Introduction

The project is focused on development of a specialized solver for a 
quadratic model predictive control problem, and a software module, 
which uses this solver to control walking behavior of a 
[[Nao|http://www.aldebaran-robotics.com]] humanoid robot.

The development has been performed within the
[[Mobile Robotics and Olfaction Lab|http://www.aass.oru.se/Research/Learning/index.html]]
at &Ouml;rebro University under the supervision of [[Dimitar Dimitrov|http://www.drdv.net]].

All related derivations, a more detailed description of results and implementation
can be found in my [[Master's thesis|http://asherikov.github.com/files/asherikov-ms-thesis.pdf]].


---
## Source code and documentation

* The Nao module:  
> Sources <http://github.com/asherikov/oru_walk_module>  
> Documentation <http://asherikov.github.com/oru_walk_module>


* The specialized MPC solver, that produces trajectory for a center of mass:
> Sources <http://github.com/asherikov/smpc_solver>  
> Documentation <http://asherikov.github.com/smpc_solver>


* The inverse kinematics library:
> Sources <http://github.com/asherikov/nao_igm>  
> A brief overview <https://github.com/asherikov/nao_igm/blob/master/README.markdown>
Note that the code of this library is partially generated by Maple, Maple
sources and different versions of the inverse kinematics functions are stored
in a separate branch:  
<https://github.com/asherikov/nao_igm/tree/MapleGeneratedFunctions>

---
## Key differences from the built-in module
* We do not eliminate the equality constraints (due to the system dynamics) when 
forming the QP problem for MPC. This allows us to have variations of time 
discretization and height of the center of mass from one preview window to the 
next without pre-computations. The resulting QP is larger but more structured, 
an exploitation of this structure leads to faster computation.

* The inverse kinematics module works with position of the center of mass instead
of position of the trunk.


---
## Video demonstration

There are several videos recorded from different viewpoints, they can be chosen
from a playlist.

<iframe width="560" height="315" 
src="http://www.youtube.com/embed/videoseries?list=PL93B16B2910EC7F3D&amp;hl=en_US" 
frameborder="0" allowfullscreen>
</iframe>

Alternatively, you can watch the videos on YouTube:  
<http://www.youtube.com/playlist?list=PL93B16B2910EC7F3D&feature=plcp>


A simulation of the walk is demonstrated in the following set of videos. The robot 
is represented by a skeletal model. The red box indicates a position of the center 
of mass. Also, you can see the reference frame switching from one foot to another
during the walk. We use one of two inverse kinematics functions depending on the
current reference foot.

<iframe width="560" height="315" 
src="http://www.youtube.com/embed/videoseries?list=PL509215FDE5DB30C2&amp;hl=en_US" 
frameborder="0" allowfullscreen>
</iframe>

<http://www.youtube.com/playlist?list=PL509215FDE5DB30C2&feature=plcp>

---
## Parameters

The parameters, that we used during the recording, are described below.

* Error feedback for CoM position
    - gain = 0.3;
    - threshold = 0.004 meter (smaller errors were ignored);

* MPC solver:
    - gain for reference ZMP positions = 8000 (reference ZMP positions are centers of
footsteps);
    - penalty for the velocity of CoM = 1;
    - penalty for the acceleration of CoM = 1;
    - penalty for the jerk of CoM = 1 (jerk is the control input);

* Steps:
    - step height = 0.02 meter;
    - step length = 0.04 meter (this is a relative distance from the position of the other 
foot, i.e. full step length is 0.08);
    - trajectories of a swing foot were build using Bezier curves;

* Preview window:
    - number of sampling intervals in a preview window = 40;
    - time in a single support = 400 ms.
    - time in a double support = 120 ms.
    - length of a sampling interval = 40 ms.

> Since we solve IK twice (the reason behind this is explained 
[[here|http://asherikov.github.com/oru_walk_module/pArch.html#pIGM]]) we need to get
positions of CoM at 20 ms and 40 ms (one and two control loops respectively). 
Therefore we set the length of the first two sampling intervals in a preview window 
to 20 ms.

---
## Performance

The data was collected during execution on the Nao v3.2, which is equipped with
AMD GEODE 500MHz CPU. No external disturbances were applied. Note that we use a 
real time scheduling policy (SCHED_FIFO).

The execution time of one control loop (in seconds):
<table border="1">
<tr>
    <td></td>
    <td>Active set method</td>
    <td>Logarithmic barrier method</td>
</tr>
<tr>
    <td>min</td>
    <td>0.001867</td>
    <td>0.004108</td>
</tr>
<tr>
    <td>mean</td>
    <td>0.003071</td>
    <td>0.004834</td>
</tr>
<tr>
    <td>max</td>
    <td>0.004650</td>
    <td>0.006012</td>
</tr>
</table>

This time includes:

* Logging (takes about 0.0005 sec.).
* Solution of the QP problem
<table border = "1">
<tr>
    <td></td>
    <td>Active set method</td>
    <td>Logarithmic barrier method</td>
</tr>
<tr>
    <td>min</td>
    <td>0.000490</td>
    <td>0.002569</td>
</tr>
<tr>
    <td>mean</td>
    <td>0.001259</td>
    <td>0.003016</td>
</tr>
<tr>
    <td>max</td>
    <td>0.002782</td>
    <td>0.004126</td>
</tr>
</table>
* Two solutions of inverse kinematics.

Active set method activates from 0 to 7 constraints. In the initial and final double supports 
constraints are not added, during the walk the number of constraints is usually 6 or 7. 

The solver is not hot-started.

Solution of inverse kinematics takes from 1 to 3 iterations.

---
## Publications

* [[!bibtex file=".biblio.bib" key="Dimitrov-IROS11" format="citation"]]
[[(preprint)|http://www.aass.oru.se/Research/Learning/drdv_dir/publications/iros11/iros11_1.html]]
[[!toggle id="bibtexentry" text="(bibtex)"]]
[[!toggleable id="bibtexentry" text="""
[[!bibtex file=".biblio.bib" key="Dimitrov-IROS11" format="raw"]]
"""]] 
